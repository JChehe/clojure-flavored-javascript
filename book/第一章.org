* 函数式javascript

本章介绍JavaScript的函数式背景：

1. 为什么说 JavaScript 是函数式语言
2. 我们为什么要关心函数式编程
3. 为什么不用Underscore
4. 要作为完整的函数式语言，JavaScript 还缺些什么？

** 最好在看本书之前

*** 能看懂JavaScript代码
这既不是一本介绍 Clojure 也不是介绍 JavaScript 的书，这是介绍如何用 JavaScript 函数式编程的书。其中一些函数式的思想和表现形式都借用了 Clojure，因此叫做 Clojure 风格的函数式 JavaScript，但是并不要求在读本书前会 Clojure[fn:1]，而只需要能阅读 JavaScript 代码，那就足够了。 如果你会 Clojure，可以完全忽略我解释 Clojure 代码的段落，当然 JavaScript 的部分才是重点。

*** 你可能买错书了，如果你是
**** 想学 JavaScript
这不是一本 JavaScript 的教科书，这里只会介绍如何用 JavaScript 进行函数式编程，所以如果想要系统学习 JavaScript 的话，我猜看一看《JavaScript 语言精粹》已经足够了。另外如果读者的英文好的话，还有一本可以在线免费阅读的[[https://leanpub.com/javascriptallongesix/read][《JavaScript Allonge》]]。

**** 想学 Clojure
同样的，这也不是 Clojure 的教科书，这里只含有一些用于阐述函数式编程思想的 Clojure 代码。作为副作用，你确实可以学到一些 Clojure 编程的知识，但很可能是非常零碎不完整的知识。如果是想要系统的了解和学习 Clojure 的话，非常推荐《The Joy of Clojure》[fn:2]，另外，如果读者英文比较好，还有一本可以免费在线阅读的[[http://braveclojure.com][《CLOJURE for the BRAVE and TRUE》]] 也非常的不错。

**** 函数式编程的专家
如果你已经在日常工作或学习中使用 Scala，Clojure 或者 Haskell 等函数式语言编程的话，那么本书对你在函数式编程上的帮助不会太大。
*不过*：这本书对解你从函数式语言迁移到 JavaScript 编程的不适应该是非常有效的，当然，这也正是本书的目的之一。

*** 准备环境
在开始阅读本书之前，如果你希望能运行书中的代码的话，可能需要一些环境的配置。当然如果你使用 emacs 阅读本书的源码的话，对于大部分代码只需要光标放在在代码处按 =c-c c-c= 即可。


**** JavaScript

原生的 JavaScript 没有什么好准备的，可以通过 Node 或者 Firefox（推荐）的 Console 运行代码。当然书中会有一些用 sweet.js 写的 macro，也需要安装 sweet.js。

***** 安装 Node/iojs

1. 下载[[https://nodejs.org/][ nodejs]]

2. 如果使用 mac，可以直接用 brew 安装
#+BEGIN_SRC sh
  brew install node 
  # 或者
  brew install iojs
#+END_SRC

***** 安装 sweet.js
在安装完 node 之后命令行输入：
#+BEGIN_SRC sh
npm install -g sweet.js
#+END_SRC

***** 安装 ru-lang[TODO]
很多 BONUS 的章节会用到我编写的实验性的 *入语言* ，可以通过 npm 安装

#+BEGIN_SRC sh
npm install -g ru-lang
#+END_SRC

当然也可以直接访问 http://ru-lang.org/try 使用在线编辑器。

另外，书中所有源代码会在 [TODO] 我的 github 上下到, 无需搭建环境，只需要 =git clone= 后 =npm install= 就好了。

**** Clojure

书中的 Clojure 代码大多都用来描述函数式编程的概念，当然如果想要运行书中的 Clojure 代码，首先需要安装 [[http://www.oracle.com/technetwork/java/javase/downloads/index.html][JVM 或者 JDK]]，至少1.6，推荐安装1.8。

***** 安装 leiningen
leiningen 是 clojure 的包管理工具，类似于 node 的 npm，ruby 的 bundle，python 的 pip。 另外 leinigen 还提供脚手架的功能。可以通过[[http://leiningen.org/][官网]]的脚本安装。 mac 用户可以简单的使用 =brew install leiningen= 安装。

安装完之后可以通过 repl 运行 clojure 代码了
#+BEGIN_SRC sh
lein repl
(+ 1 1)
2
#+END_SRC

***** 编辑器
如果更喜欢使用编辑器而不是 REPL，我推荐非 emacs 用户使用 [[http://lighttable.com/][Light Table]], 对 Clojure 和 ClojureScript 的支持非常好。当然已经在使用 Emacs，那就更完美了，emacs cider mode是个clojure 编程不错的选择。

** JavaScript也是函数式语言?

说到 JavaScript 可能第一反应会是一门面向对象的语言。事实上，JavaScript 是基于原型（prototype-based）的 *多范式* 编程语言。也就是说面向对象只是 JavaScript 支持的其中一种范式而已，由于 JavaScript 的函数是一等公民，它也支持函数式编程范式。

*** 编程范式
常见的编程范式有三种，命令式，面向对象以及函数式，事实上还有第四种，逻辑式编程。 如我们在大学时学过的C语言，就是标准的命令式语言。而如果你在大学自学过Java打过黑工的话，那么你对面向对象也再熟悉不过了吧。而可能大部分人（以为）接触函数式的机会比较少，因为它是更接近于数学和代数的一种编程范式。

**** 命令式
这恐怕是我们最熟悉的编程范式了(大部分计算机课程都会是C)，命令式顾名思义就是以一条条命令的方式编程，告诉计算机我需要先做这个任务，然后另一个任务。还有一些控制命令执行过程的流控制，比如我们熟悉的循环语句：

#+BEGIN_SRC js
for(var i=0;i<10;i++){
  console.log('命令',i)
}
#+END_SRC

当然还有分支语句，switch等等，都是用来控制命令的执行 _过程_。

**** 面向对象

这恐怕是目前最常见的编程范式了（绝大部分的工程项目的语言都会是面向对象语言）。而面向对象的思想则更接近于现实世界，封装好的对象之间通过消息互相传递信息。面向对象有一些我们熟悉的概念比如封装，继承，多态等等。而面向对象的思维主要是通过抽象成包含状态和一些方法的对象来解决问题，可以通过继承关系复用一些方法和行为。

**** 函数式
函数式则更接近于数学，简单来说就是对表达式求值。跟面向对象有所不同的是函数式对问题的抽象方式是抽象成 带有动作的函数。其思维更像是我们小时候解应用题时需要套用各种公式来求解的感觉。当然函数式跟面向对象一样还包含了很多的概念，比如高阶函数，不可变性，惰性求值等等。

#+CAPTION: 主要的编程范式
[[./images/paradigm.png]]

**** 逻辑式编程
可能这个名词听的比较少，但是我们经常在用而却可呢过没有意识到的 SQL 的 query 语句就是逻辑式编程。所谓逻辑式，就是通过提问找到答案的编程方式。比如：

#+BEGIN_SRC sql
select lastname from someTable where sex='女' and firstname in ('连顺','女神')
#+END_SRC

这里问了两个问题：

1. 性别是女？
2. 名字必须是“连顺”或者“女神”？

那么得到的答案就是符合问题描述的结果集了。

除了最常见的 SQL，Clojure 也提供了 =core.logic= 的库方便进行逻辑式编程，我也会在 最后一章讲到用 JavaScript 如何进行逻辑式编程。[fn:3]
**** JavaScript对函数式的原生支持

说了这么多种编程范式，JavaScript 对函数式的支持到底如何呢？

首先如果语言中的函数不是一等的，那么也就跟函数式编程也就基本划清界限了。比如Java 8之前的版本，值和对象才是一等公民，要写一个高阶函数可能还需要把函数包在对象中才行。[fn:4]

幸好 JavaScript 中的函数是一等函数，所谓一等，就是说跟值一样都是一等公民，所有值能到的地方，都可以替换成函数。例如，可以跟值一样作为别的函数的参数，可以被别的函数想值一样返回，而这个“别的函数”叫做 /高阶函数/。

**** COMMENT 函数作为参数
函数作为参数最典型的应用要数 map 了，想必如果没有使用过 Underscore，也或多或少会用过 ECMAScript 5 中 Array 的 map 方法吧。

#+BEGIN_SRC js
  [1, 2, 3, 4].map(function(x) {
    return ++x;
  });
#+END_SRC

#+RESULTS:
: Please install 'z' first!
: undefined

可以看到函数 =function(x){return x++}= 是作为参数被传入 Array 的 =map= 方法中。map 是函数式编程最常见的标志性函数，想想在 ECMAScript 5 出来之前应该怎么做类似的事情：

#+BEGIN_SRC js
  var array = [1, 2, 3, 4];
  var result = [];
  for(var i in array){
    result.push(++i);
  }

#+END_SRC

这段命令式的代码跟利用 map 的函数式代码解决问题的方式和角度是完全不同的。命令式需要操心所有的过程，如何遍历以及如何组织结果数据。而 map 由于将遍历，操作以及结果数据的组织的过程封装至 Array 中，从而参数化了最核心过程。而这里的核心过程就是 map 的参数里的匿名函数中的过程，也是我们真正关心的主要逻辑。

**** 函数作为返回值
函数作为返回值的用法可能在 JavaScript 中会更为常见。而且在不同场景下被返回的函数又有着不同的名字。

***** 柯里化
我们把一个多参的函数变成一次只能接受一个参数的函数的过程叫做柯里化。如：

#+BEGIN_SRC js
var curriedSum = curry(sum)
var sum5 = curriedSum(5)
var sum5and4 = sum5(4) //=> 9
sum5and4(3) // => 12
#+END_SRC

当然柯里化这样做的目的非常简单，可以部分的配置函数，然后可以继续使用这些配置过的函数。当然，我会在第四章函数组合那里更详细的解释为什么要柯里化，在这之前闲不住的读者可以先猜猜为什么要把柯里化放函数组合那一章。

***** thunk
thunk（槽）[fn:5] 是指有一些操作不被立即执行，也就是说准备好一个函数，但是不执行，默默等待着合适的时候被合适的人调用。我实在想不出能比下图这个玩意更能解释 thunk 的了。 在下一章，你会见到如何用 thunk 实现惰性序列。

#+CAPTION: thunk 像是一个封装好待执行的容器
[[./images/thunk.png]]

**** 越来越函数式的ES6
ECMAScript 6（也被叫做 ECMAScript 2015，本书中会简称为 ES6）终于正式发布了，新的规范有非常的新特性，其中不少借鉴自其他函数式语言的特性，给 JavaScript 语言添加了不少函数式的新特性。

#+BEGIN_QUOTE
虽然浏览器厂商都还没有完全实现 ES6 的所有规范，但是其实我们是可以通过一些中间编译器使用大部分的 ES6 的新特性，如

*Babel*

这是目前支持 ES6 实现最多的编译器了，没有之一。 主要是 Facebook 在维护，因此也可以编译 Facebook 的 React。这也是目前能实现尾递归优化的唯一编译器。不过关于尾递归只能优化尾子递归，相互递归的优化还没有实现。

*Traceur*

Google 出的比较早得一个老牌编译器，支持的 ES6 也不少了。但是从 github 上来看似乎已经没有 babel 活跃了。

当然，除了这些也可以直接使用 FireFox。作为 ES6 规范的主要制定者之一的 Mozilla 出的 Firefox 当然也是浏览器中实现 ES6 标准最多的。
#+END_QUOTE

***** 箭头函数

这是 ES6 发布的一个新特性，虽然 Firefox 支持已久了，不算什么新东西，但是标准化之后还是比较令人激动的。 /箭头函数/ 也被叫做 /肥箭头/（fat arrow）[fn:6]，大致是借鉴自 CoffeeScript 或者 Scala 语言。箭头函数是提供词法作用域的匿名函数。

***** 声明一个箭头函数

你可以通过两种方式定义一个箭头函数：
#+BEGIN_EXAMPLE
([param] [, param]) => {
   statement
}
// 或者
param => expression
#+END_EXAMPLE

表达式可以省略块（block）括号，而多行语句则需要用块括号括起来。

**** 为什么要用箭头函数

虽然看上去跟以前的匿名函数没有什么区别，我们可以对比旧的匿名函数是如何写一个使数组中数字都乘 2 的函数.
#+BEGIN_SRC js
var a = [1, 2, 3, 4,5];
a.map(function(x){ return x*2 });
#+END_SRC

而使用箭头函数会变成：
#+BEGIN_SRC js
a.map(x => x*2);
#+END_SRC

使用箭头函数可以少写 function 和 return 以及块括号，从而让我们其实更关心的转换关系变得更明显。略去没用的长的匿名函数定义其实可以让代码更简洁更可读。特别是在传入高阶函数作为参数的时候，=map(x => x*2)= 更形象和突出的表达了变换的逻辑。

**** 词法绑定

如果你觉得这种简化的语法糖还不足以说服你改变匿名函数的写法，那么想想以前写匿名函数中的经常需要 =var self=this= 的苦恼吧。

#+BEGIN_SRC js -n -r
    var Multipler = function(inc){
      this.inc = inc;
    }
    Multipler.prototype.multiple = function(numbers){
      var self = this; // <= (ref:selfthis)
      return numbers.map(function(number){
        return self.inc * number; // <= (ref:self)
      })
    }
    new Multipler(2).multiple([1,2,3,4]) // => [ 2, 4, 6, 8 ]
#+END_SRC

#+RESULTS:

- [[(selfthis)][第(selfthis)行]]保持 Multipler 的 this 引用的缓存
- [[(self)][第(self)行]]使用 self 引用 Multipler 的实例而不是 this

这样做很怪不是吗，因此经常出现在各种面试题中，让你猜猜 this 到底是谁。或者让你去修正 this 绑定，方法如此之多，但是不管是使用 EcmaScript 5 的 bind，还是 map 的第三个参数来保证 this 的绑定不会出错，都逃脱不了要手动修正 this 绑定的命运。

那么如果用箭头函数就不会存在这种问题：
#+BEGIN_SRC js
Multipler.prototype.multiple = function(numbers){
  return numbers.map(number => number*this.inc);
};

new Multipler(2).multiple([1,2,3,4]);// => [ 2, 4, 6, 8 ]
#+END_SRC

现在，箭头函数里面的 this 绑定的是外层函数的 this 值，不会受到运行时上下文的影响。[fn:7]而是从词法上就能轻松确定 this 的绑定。不需要 =var self=this= 了是不是确实方便了许多，不仅不会再被各种怪异的面试题坑了，还让代码更容易推理。

**** 尾递归优化
Clojure 能够通过 _recur_ 函数对 _尾递归_ 进行优化，但是 ES5 的 JavaScript 实现是不会对尾递归进行任何优化，很容易出现 _爆栈_ 的现象。但是 ES6 的标准已经发布了对尾递归优化的支持，下来我们能做的只是等各大浏览器厂商的实现了。

不过在干等原生实现的同时，我们也可以通过一些中间编译器如 Babel，把 ES6 的代码编译成 ES5 标准 JavaScript，而在 Babel 编译的过程就可以把尾递归优化成循环。


*** Destructure

在解释 Destructure[fn:8]之前，先举个生动的例子，比如吃在奥利奥的是时候，我的吃法是这样的：

1. 掰成两片，一片是不带馅的，一份是带馅的
2. 带馅的一半沾一下牛奶
3. 舔掉馅
4. 合起来吃掉

如果写成代码，大致应该是这样的：
#+BEGIN_SRC js
var orea = ["top","middle","bottom"]
var top = orea.shift(),middleAndButton=orea // <1>
var wetMiddleAndButton = dipMilk(middleAndButton) // <2>
var button = lip(wetMiddleAndButton) // <3>
eat([top,button]) // <4>
#+END_SRC

注意那个诡异的 =shift= ，如果用 destructure 会写得稍微优雅一些：
#+BEGIN_SRC js
var [top, ...middleAndButton] = ["top","middle","bottom"] // <1>
var wetMiddleAndButton = dipMilk(middleAndButton) // <2>
var button = lip(wetMiddleAndButton) // <3>
eat([top,button]) // <4>
#+END_SRC

有没有觉得我掰奥利奥的姿势变酷了许多？这就是 destructure，给定一个特定的模式 =[top, ...middleAndButton]=，让数据 =["top","middle","bottom"]= 按照该模式匹配进来。同样的，会专门在第6章介绍模式匹配这个概念，虽然它不是 Clojure 的重要概念，但是确实 Scala 或 Haskell 的核心所在。不过可以放心的是，你不必先学习 Scala 和 Haskell，我还是会用最流行的 JavaScript 来介绍模式匹配。

#+CAPTION: 我觉得这个玩具可以特别形象的解释模式匹配这个概念
[[./images/patten-matching.jpg]]

** 作为函数式语言JavaScript还差些什么

** Underscore你错了

* Footnotes

[fn:1] 就像计算机程序构造与解释中说的，lisp 语言基本没有语法，就像学习象棋的规则只用花很少的时间，而如何下好棋，才是学习的关键。

[fn:2] 中文叫 Clojure 编程乐趣，但是只有第一版的，原书已经第二版了。 我刚好有幸翻译了作者 Michael Fogus 另一本《JavaScript 函数式编程》。

[fn:3] 当然逻辑式编程并不是本书的重点，也不会展开深入介绍，如果有兴趣，可以联系出版社让我在写一本。

[fn:4] 事实上，JavaScript 或者 Scala 其实也是通过把函数作为一种特殊的对象，来把函数变成一等公民。不过，在使用上基本感觉不到函数是对象。而在 Clojure 中，函数确确实实就是一等公民，因为所有 lisp 语言都一样，代码即是数据。

[fn:5] thunk 的翻译“槽”来自《计算机程序的构造与解释》，但是我个人倾向不做翻译，因为很难从“槽”这一个字中获取到足够多的解释。

[fn:6] 相对于廋箭头（thin arrow）。

[fn:7] 正如我说的本书不是 JavaScript 的教科书，所以关于动态绑定和词法绑定，这里不会做太多的解释。简单的解释就是词法绑定可以从词法分析（通俗的说就是肉眼直接能看出来）判断出来绑定的值，而相反动态绑定需要根据运行时上下文决定。

[fn:8] 同样的，我读的中文技术书太少，倾向于不翻译此类专业名词。翻译错了反而体会不出来原词的意思。这里明显 structure 是构造，前面加 de 词根，就是构造的反过程。

